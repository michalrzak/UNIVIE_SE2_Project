package at.ac.univie.se2.ws21.team0404.app.model.transaction;


import at.ac.univie.se2.ws21.team0404.app.utils.NonNull;
import at.ac.univie.se2.ws21.team0404.app.utils.Nullable;

import at.ac.univie.se2.ws21.team0404.app.model.categories.Category;

import java.util.Optional;

/**
 * Class, used to save information about a transaction.
 *
 */
public class Transaction {
    private final int id;

    @Nullable
    private Category category;
    private ETransactionType type;
    private int amount; // in euro cent; TODO: change this to a special money class?

    /**
     * Function, which validates the amount field. May be moved to special money class if it gets
     * implemented.
     * For now, amount is allowed to be non-negative (so it can be zero).
     * TODO: can amount be zero?
     *
     * @param amount the variable to check
     * @return true if amount is valid, false if amount is invalid
     */
    private static boolean validateAmount(int amount) {
        return amount >= 0;
    }


    // id should be imo auto generated
    // TODO: change id to be autogenerated
    public Transaction(int id, @Nullable Category category, @NonNull ETransactionType type, int amount) {
        this.id = id;
        this.category = category;
        this.type = type;

        if(!validateAmount(amount)) {
            throw new IllegalArgumentException("amount is of an invalid value"); // TODO: make this own exception?
        }

        this.amount = amount;
    }

    /*
     * Getters-section
     */

    public int getId() {
        return id;
    }

    /**
     * Not every transaction needs to have a category assigned. (See FR3 for reference)
     *
     * @return Optional category
     */
    @NonNull
    public Optional<Category> getCategory() {
        if (category == null) {
            return Optional.empty();
        }
        return Optional.of(category);
    }

    @NonNull
    public ETransactionType getType() {
        return type;
    }

    public int getAmount() {
        return amount;
    }

    /**
     * Allow subclasses to access the Category object without the Optional. Makes handling a bit easier
     * @return category, may be null
     */
    @Nullable
    protected Category getRawCategory() {
        return category;
    }

    /*
     * Setters section
     */

    public void setCategory(@NonNull  Category newCategory) {
        category = newCategory;
    }

    public void setType(@NonNull ETransactionType newType) {
        type = newType;
    }

    public void setAmount(int newAmount) {
        if(!validateAmount(amount)) {
            throw new IllegalArgumentException("amount is of an invalid value"); // TODO: make this own exception?
        }

        amount = newAmount;
    }

    @Override
    public int hashCode() {
        return id; // as id should be unique, it can be used as a hash code
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof Transaction)) {
            return false;
        }
        Transaction that = (Transaction) o;
        return id == that.id;
    }
}
